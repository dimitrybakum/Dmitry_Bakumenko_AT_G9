Задания до следующего занятия:

00. PreBaseTask (для него создаем отдельный пакет pretask,
 в каждом классе метод main, в теле которого выполняем само задание, там же и запускаем):

- класс MessageExample, выведите на экран любое сообщение, которое вы хотите;
- класс SumExample, посчитайте и выведите на экран сумму двух чисел (например, 5 + 7);
- класс VariableExample, объявите две целочисленные переменные и выведите их значения на экран;
- класс AnotherVariableExample, объявите две переменные с плавающей точкой (тип double) и присвойте им значения, выведите значения переменных на экран;
- класс VariableAssignment, объявите целочисленную переменную и присвойте ей значение. Выведите значение на экран;
- класс ConditionalExample, объявите целочисленную переменную и используйте условный оператор if, чтобы проверить, больше ли она 10, выведите результат проверки на экран;
- класс NumberPrinting,  используйте цикл for и выведите на экран числа от 1 до 10;
- класс SimpleLoopExample, объявите целочисленную переменную и используйте цикл for, чтобы вывести числа от 1 до этой переменной;
- класс MathOperatorsExample, объявите две целочисленные переменные и выполните операции сложения, вычитания, умножения и деления, выведите результаты на экран;
- класс VariableReassignment, объявите целочисленную переменную, переопределите её значение и выведите оба значения на экран;
- класс ConditionalLoopExample, используйте цикл for, чтобы вывести четные числа от 1 до 10, с использованием условного оператора if для пропуска нечетных чисел;
- класс MultiplicationTable, используя цикл for, выведите на экран таблицу умножения для числа 5 (1  5, 2  5, и так далее);
- класс BooleanExample, объявите булеву переменную и выведите её значение на экран;
- класс StringManipulationExample, объявите две строки, объедините их при помощи операции "+" и выведите результат на экран;
- класс IncrementDecrementExample, объявите целочисленную переменную и используйте операторы инкремента и декремента для изменения её значения, выведите результаты на экран;
- класс SimpleMathExample, объявите две целочисленные переменные, представляющие длину и ширину прямоугольника, вычислите и выведите на экран его площадь;

0. BaseTask (для него создаем отдельный пакет basetask, обьекты классов задания запускаем в main методе отдельного класса раннера, далее "раннер")

- создать класс TrainMethodsString и в нем
-- создать невозвратный метод printMama, который ничего не принимает на вход печатает в консоль «мама мыла раму»
-- создать невозвратный метод printPapa, который ничего не принимает на вход печатает в консоль «папа мыла раму»
-- создать невозвратный метод printString, который принимает на вход строку и печатает в консоль эту строку
-- создать невозвратный метод printMamaString, который принимает на вход строку и печатает в консоль «мама мыла » и эту строку
-- создать класс TrainMethodsStringRunner с методом main, в этом методе создать обьект класса TrainMethodsString и вызвать всего его методы

- создать класс TrainMethodsPrimitive и в нем
-- создать невозвратный метод printInt, который принимает на вход целое число (int) и печатает в консоль «я получил на вход число » и это число
-- создать невозвратный метод printLong, который принимает на вход целое число (long) и печатает в консоль «я получил на вход  длинное число » и это число
-- создать невозвратный метод printChar, который принимает на вход символ (char) и печатает в консоль «я получил на вход символ » и это число
-- создать невозвратный метод printFloat, который принимает на вход дробное число (float) и печатает в консоль «я получил на вход дробное число » и это число
-- создать невозвратный метод printDouble, который принимает на вход дробное число (double) и печатает в консоль «я получил на вход длинное дробное число » и это число
-- создать невозвратный метод printShort, который принимает на вход целое число (short) и печатает в консоль «я получил на вход короткое число » и это число
-- создать невозвратный метод printByte, который принимает на вход целое число (byte) и печатает в консоль «я получил на вход очень короткое число » и это число
-- создать невозвратный метод printBoolean, который принимает на вход булево значение (boolean) и печатает в консоль «я получил на вход булево » и это число
-- создать класс TrainMethodsPrimitiveRunner с методом main, в этом методе создать обьект класса TrainMethodsPrimitive и вызвать всего его методы

- создать класс TrainMethodsReturn и в нем
-- создать метод returnNewInt, который принимает на вход целое число (int) и возвращает это число умноженное на 3
-- создать метод returnNewLong, который принимает на вход целое число (long) и возвращает это число минус 4
-- создать метод returnNewChar, который принимает на вход символ (char) и возвращает строку из двух таких символов
-- создать метод returnNewFloat, который принимает на вход дробное число (float) и возвращает это число деленное на 2
-- создать метод returnNewDouble, который принимает на вход дробное число (double) и возвращает это число плюс 8
-- создать метод returnNewShort, который принимает на вход целое число (short) и возвращает это число минус 1
-- создать метод returnNewByte, который принимает на вход целое число (byte) и возвращает это число умноженное на 2
-- создать метод returnNewBoolean, который принимает на вход булево значение (boolean) и возвращает обратное булево
-- создать класс TrainMethodsReturnRunner с методом main, в котором создать обьект класса TrainMethodsReturn, и отпечатать в консоль значение, возвращаемое каждым из его методов в виде "метод <название метода> вернул " и возвращаемое значение

- создать класс TrainMethodsIf и в нем
-- создать метод returnNewInt, который принимает на вход целое число (int) и если оно меньше 8, то возвращает это число умноженное на 7, в противном случае деленное на 4
-- создать метод returnNewLong, который принимает на вход целое число (long) и если оно больше 300, то возвращает это число минус 300, в противном случае плюс 20
-- создать метод returnNewChar, который принимает на вход символ (char) и если это 'g', то возвращает строку "go", в противном случае строку из этого символа с префиксом "o"
-- создать метод returnNewFloat, который принимает на вход дробное число (float) и если оно равно 0.67, то возвращает это число, в противном случае число умноженное на 2
-- создать метод returnNewDouble, который принимает на вход дробное число (double) и если оно больше 30, но меньше 80, то  возвращает это число плюс 87, если оно больше 80, но меньше 400, то возвращает это число минус 87, а если оно больше 400, то деленное на 4, в остальных случаях возвращает само число
-- создать невозвратный метод returnNewBoolean, который принимает на вход булево значение (boolean) и если оно true то печатает в консоль "Я получил на вход значение истины", в противном случае печатает в консоль "Я получил на вход ложь"
-- создать класс TrainMethodsIfRunner с методом main, в котором создать обьект класса TrainMethodsIf, и отпечатать в консоль значение, возвращаемое каждым из его методов в виде "метод <название метода> вернул " и возвращаемое значение, последний метод просто вызвать

- создать класс Mouse и в нем
-- строковое поле name
-- целочисленное поле age
-- конструктор, принимающий имя и возраст и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printMouseDetails, который печатает в консоль информацию о мыши в виде "Я мышь, меня зовут <имя мыши> и мне <возраст мыши> лет"

- создать класс Souce и в нем
-- строковое поле name
-- строковое поле color
-- конструктор, принимающий имя и цвет и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printSouceDetails, который печатает в консоль информацию о соусе в виде "Это соус <имя соуса> <цвет соуса> цвета"

- создать класс Bee и в нем
-- строковое поле gender
-- длинное целочисленное поле weight
-- конструктор, принимающий пол и массу и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printBeeDetails, который делит 500 кг на массу пчелы и печатает в консоль информацию о ней в виде "Я легче лося в <> раз"

- создать класс Obstacle и в нем
-- строковое поле description
-- строковое поле severity
-- конструктор, принимающий описание и важность и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printObstacleDetails, который печатает в консоль информацию о трудности в виде "Возникло <важность> препятствиие <описание препятствия>"

- создать класс Pineapple и в нем
-- строковое поле grade
-- дробное числовое поле heatCapacity
-- конструктор, принимающий сорт и теплоемкость и инициализирующий соответствующие поля
-- геттеры и сеттеры на каждое поле
-- невозвратный метод printPineappleDetails, который сравнивает теплоемкость ананаса с 2140 и если она больше, то печатает в консоль "Я ананас, теплоемкость которого больше, чем у ветчины", в противном случае печатает в консоль "В ветчине тепла запасется больше :(
"

- создать класс TrainMethodsObjects и в нем
-- создать метод processMouse, который принимает на вход обьект мыши (Mouse)
 и печатает в консоль ее имя, возраст и вызывающий метод printMouseDetails
-- создать метод processSouce, который принимает на вход обьект соуса (Souce) и печатает в консоль его имя, цвет и вызывающий метод printSouceDetails
-- создать метод processBee, который принимает на вход обьект пчелы (Bee)
 и печатает в консоль ее пол, вес и вызывающий метод printBeeDetails
-- создать метод processObstacle, который принимает на вход обьект препятствия (Obstacle) и печатает в консоль его описание, важность и вызывающий метод printObstacleDetails
-- создать метод processPineapple, который принимает на вход обьект ананаса (Pineapple)
 и печатает в консоль его сорт, теплоемкость и вызывающий метод printPineappleDetails
-- создать класс TrainMethodsObjectsRunner с методом main, в котором создать обьект класса TrainMethodsObjects, и вызвать всего его методы

1. CycleTask (для него создаем отдельный пакет cycletask и каждое подзадание делаем в отдельном классе, имена классов и методов на ваше усмотрение, запускаем в отдельном классе CycleTaskRunner, где создаем обьект соответствующего типа и вызываем нужный метод)
- используя while вывести в консоль все числа от 0 до 20 в 1 строку через пробел
- используя for вывести в консоль каждое нечетное число от 3 до 19 включительно
- создать пустой массив типа int и размера n = 7 и заполнить его случайными элементами используя Random.nextInt(n)

- пройти по массиву и вывести в консоль все элементы
- вывести в консоль все элементы массива в обратном порядке
- каждый элемент массива умножить на 5 и вывести результат в консоль
- каждый элемент массива возвести в квадрат и вывести результат в консоль
- найти минимальный элемент массива и вывести результат в консоль
- поменять местами первый и последний элементы и вывести результат в консоль
- отсортировать элементы массива в порядке убывания (любым способом) и вывести результат в консоль

2. BubbleTask (для него создаем отдельный пакет bubbles)
- создать класс Bubble
- у пузырька должен быть обьем, газовый состав
- он должен уметь лопаться с выводом в консоль «Cramp!»
- обьем пузырька постоянный и равен 0.3 мм2, а газовый состав переменный в зависимости от образующего газа и задается в конструкторе класса

- создать абстрактный класс Water
- у воды есть такие характеристики, цвет, прозрачность, запах, температура

- создать класс SparklingWater, являющийся дочерним Water
- у газировки есть пузырьки
- вода заполняется пузырьками при упаковке на заводе, для этого у нее есть метод pump(Bubble[] bubbles)
- у газировки есть метод degas(), который удаляет пузырьки по одному и вызывает их лопанье
- 1 литр воды содержит 10 тыс пузырьков

- создать класс Bottle
- у него есть обьем
- есть вода
- есть метод open(), который вызывает метод degas() в газировке

- создать класс Runner, содержащий main
- в нем создать 3 бутылки, объёмом 0.05, 0.1, 0.2 лира с газировкой
- открыть поочередно все бутылки и выпустить из них газ


+Обязательно к следующему занятию:
- зарегистрироваться (если еще нет) на https://github.com/
- скачать и установить git с https://git-scm.com/downloads
- открыть git bush, выполнить git --version и убедиться, что гит работает и показывает версию себя